<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üéÆ ÌôîÎ†§Ìïú ÌÖåÌä∏Î¶¨Ïä§ Í≤åÏûÑ</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Orbitron', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 25%, #f093fb 50%, #4facfe 75%, #00f2fe 100%);
      background-size: 400% 400%;
      animation: gradientShift 15s ease infinite;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .game-title {
      font-family: 'Press Start 2P', cursive;
      text-shadow:
        0 0 10px #fff,
        0 0 20px #fff,
        0 0 30px #e60073,
        0 0 40px #e60073,
        0 0 50px #e60073,
        0 0 60px #e60073,
        0 0 70px #e60073;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.8; }
    }

    .neon-box {
      box-shadow:
        0 0 5px #fff,
        0 0 10px #fff,
        0 0 15px #0ff,
        0 0 20px #0ff,
        0 0 25px #0ff,
        inset 0 0 15px rgba(0, 255, 255, 0.2);
    }

    .game-canvas {
      box-shadow:
        0 0 20px rgba(255, 255, 255, 0.5),
        0 0 40px rgba(0, 255, 255, 0.4),
        0 0 60px rgba(255, 0, 255, 0.3),
        inset 0 0 30px rgba(0, 0, 0, 0.3);
      border: 3px solid rgba(255, 255, 255, 0.3);
    }

    .score-glow {
      text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(5deg); }
    }

    .float-animation {
      animation: float 3s ease-in-out infinite;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }

    .shake {
      animation: shake 0.3s ease-in-out;
    }

    @keyframes rainbow {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }

    .rainbow {
      animation: rainbow 3s linear infinite;
    }

    .particle {
      position: absolute;
      pointer-events: none;
      animation: particle-fall 1s ease-out forwards;
    }

    @keyframes particle-fall {
      to {
        transform: translateY(100px) scale(0);
        opacity: 0;
      }
    }

    .combo-text {
      animation: combo-bounce 0.5s ease-out;
    }

    @keyframes combo-bounce {
      0% { transform: scale(0) rotate(-180deg); }
      50% { transform: scale(1.2) rotate(10deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    .btn-glow {
      transition: all 0.3s ease;
    }

    .btn-glow:hover {
      transform: scale(1.05);
      box-shadow:
        0 0 10px currentColor,
        0 0 20px currentColor,
        0 0 30px currentColor;
    }

    .grid-pattern {
      background-image:
        linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
      background-size: 20px 20px;
    }
  </style>
</head>
<body class="min-h-screen flex items-center justify-center p-4 overflow-hidden">
  <!-- Particle Container -->
  <div id="particle-container" class="fixed inset-0 pointer-events-none z-50"></div>

  <!-- Main Container -->
  <div class="relative z-10">
    <!-- Title -->
    <h1 class="game-title text-2xl md:text-4xl text-center mb-8 text-white">
      TETRIS GAME
    </h1>

    <!-- Game Container -->
    <div class="flex flex-col lg:flex-row gap-6 items-start justify-center">
      <!-- Left Panel: Next & Hold -->
      <div class="flex flex-row lg:flex-col gap-4">
        <!-- Next Piece -->
        <div class="neon-box bg-black/40 backdrop-blur-md rounded-2xl p-4 border-2 border-cyan-400">
          <h3 class="text-cyan-300 text-sm font-bold mb-2 text-center">NEXT</h3>
          <canvas id="nextCanvas" width="120" height="120" class="rounded-lg bg-black/50"></canvas>
        </div>

        <!-- Hold Piece -->
        <div class="neon-box bg-black/40 backdrop-blur-md rounded-2xl p-4 border-2 border-purple-400">
          <h3 class="text-purple-300 text-sm font-bold mb-2 text-center">HOLD</h3>
          <canvas id="holdCanvas" width="120" height="120" class="rounded-lg bg-black/50"></canvas>
        </div>
      </div>

      <!-- Game Canvas -->
      <div class="relative">
        <canvas id="gameCanvas" width="300" height="600"
                class="game-canvas rounded-2xl grid-pattern bg-black/70 backdrop-blur-sm"></canvas>
        <div id="gameOver" class="hidden absolute inset-0 bg-black/80 backdrop-blur-sm rounded-2xl flex items-center justify-center">
          <div class="text-center">
            <h2 class="text-4xl font-bold text-red-500 mb-4 score-glow">GAME OVER</h2>
            <p class="text-white text-xl mb-4">Score: <span id="finalScore" class="text-yellow-400">0</span></p>
            <button onclick="restartGame()"
                    class="btn-glow bg-gradient-to-r from-green-400 to-blue-500 text-white px-6 py-3 rounded-full font-bold">
              RESTART
            </button>
          </div>
        </div>
      </div>

      <!-- Right Panel: Score & Controls -->
      <div class="space-y-4">
        <!-- Score Panel -->
        <div class="neon-box bg-black/40 backdrop-blur-md rounded-2xl p-6 border-2 border-yellow-400 min-w-[200px]">
          <h3 class="text-yellow-300 text-lg font-bold mb-4 text-center">SCORE</h3>
          <div class="space-y-3 text-white">
            <div class="flex justify-between">
              <span class="text-gray-300">Score:</span>
              <span id="score" class="score-glow text-yellow-400 font-bold">0</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-300">Lines:</span>
              <span id="lines" class="score-glow text-green-400 font-bold">0</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-300">Level:</span>
              <span id="level" class="score-glow text-cyan-400 font-bold">1</span>
            </div>
            <div class="flex justify-between">
              <span class="text-gray-300">Combo:</span>
              <span id="combo" class="score-glow text-pink-400 font-bold">0</span>
            </div>
          </div>
        </div>

        <!-- Combo Display -->
        <div id="comboDisplay" class="hidden neon-box bg-gradient-to-r from-pink-500 to-purple-500 rounded-2xl p-4 text-center">
          <p class="combo-text text-white font-bold text-2xl">üî• COMBO x<span id="comboCount">0</span> üî•</p>
        </div>

        <!-- Controls -->
        <div class="neon-box bg-black/40 backdrop-blur-md rounded-2xl p-6 border-2 border-green-400">
          <h3 class="text-green-300 text-lg font-bold mb-4 text-center">CONTROLS</h3>
          <div class="space-y-2 text-sm text-white">
            <p><span class="text-cyan-300">‚Üê‚Üí</span> Move</p>
            <p><span class="text-cyan-300">‚Üë</span> Rotate</p>
            <p><span class="text-cyan-300">‚Üì</span> Soft Drop</p>
            <p><span class="text-cyan-300">SPACE</span> Hard Drop</p>
            <p><span class="text-cyan-300">C</span> Hold</p>
            <p><span class="text-cyan-300">P</span> Pause</p>
            <p><span class="text-cyan-300">ENTER</span> Start/Restart</p>
          </div>
        </div>

        <!-- Start Button -->
        <button id="startBtn" onclick="startGame()"
                class="btn-glow w-full bg-gradient-to-r from-purple-500 to-pink-500 text-white px-6 py-4 rounded-full font-bold text-lg">
          START GAME
        </button>
      </div>
    </div>
  </div>

  <script>
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30;
    const COLORS = {
      I: '#00f5ff',
      O: '#ffea00',
      T: '#b800ff',
      S: '#00ff00',
      Z: '#ff0000',
      J: '#0000ff',
      L: '#ff8800'
    };

    const SHAPES = {
      I: [[1, 1, 1, 1]],
      O: [[1, 1], [1, 1]],
      T: [[0, 1, 0], [1, 1, 1]],
      S: [[0, 1, 1], [1, 1, 0]],
      Z: [[1, 1, 0], [0, 1, 1]],
      J: [[1, 0, 0], [1, 1, 1]],
      L: [[0, 0, 1], [1, 1, 1]]
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const nextCanvas = document.getElementById('nextCanvas');
    const nextCtx = nextCanvas.getContext('2d');
    const holdCanvas = document.getElementById('holdCanvas');
    const holdCtx = holdCanvas.getContext('2d');

    let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let currentPiece = null;
    let nextPiece = null;
    let holdPiece = null;
    let canHold = true;
    let score = 0;
    let lines = 0;
    let level = 1;
    let combo = 0;
    let gameLoop = null;
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let isPaused = false;
    let isGameOver = false;

    // Create random piece
    function createPiece() {
      const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
      const type = pieces[Math.floor(Math.random() * pieces.length)];
      return {
        type: type,
        shape: SHAPES[type],
        x: Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2),
        y: 0,
        color: COLORS[type]
      };
    }

    // Draw block with glow effect
    function drawBlock(ctx, x, y, color) {
      const gradient = ctx.createRadialGradient(
        x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2, 0,
        x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2, BLOCK_SIZE
      );
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0.5)');

      ctx.fillStyle = gradient;
      ctx.fillRect(x + 1, y + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.strokeRect(x + 1, y + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);

      // Inner glow
      ctx.shadowBlur = 10;
      ctx.shadowColor = color;
      ctx.strokeRect(x + 1, y + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
      ctx.shadowBlur = 0;
    }

    // Draw piece
    function drawPiece(ctx, piece, offsetX = 0, offsetY = 0, blockSize = BLOCK_SIZE) {
      piece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            drawBlock(ctx,
              (piece.x + x) * blockSize + offsetX,
              (piece.y + y) * blockSize + offsetY,
              piece.color
            );
          }
        });
      });
    }

    // Draw ghost piece
    function drawGhost() {
      if (!currentPiece) return;
      const ghost = { ...currentPiece, y: currentPiece.y };
      while (!collision(ghost, 0, 1)) {
        ghost.y++;
      }
      ghost.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            ctx.strokeStyle = ghost.color;
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.3;
            ctx.strokeRect(
              (ghost.x + x) * BLOCK_SIZE + 2,
              (ghost.y + y) * BLOCK_SIZE + 2,
              BLOCK_SIZE - 4,
              BLOCK_SIZE - 4
            );
            ctx.globalAlpha = 1;
          }
        });
      });
    }

    // Draw board
    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw grid
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 1;
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }
      }

      // Draw placed blocks
      board.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            drawBlock(ctx, x * BLOCK_SIZE, y * BLOCK_SIZE, value);
          }
        });
      });

      // Draw ghost piece
      drawGhost();

      // Draw current piece
      if (currentPiece) {
        drawPiece(ctx, currentPiece);
      }
    }

    // Draw next piece
    function drawNext() {
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      if (nextPiece) {
        const piece = { ...nextPiece, x: 1, y: 1 };
        drawPiece(nextCtx, piece, 10, 10, 25);
      }
    }

    // Draw hold piece
    function drawHold() {
      holdCtx.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
      if (holdPiece) {
        const piece = { ...holdPiece, x: 1, y: 1 };
        drawPiece(holdCtx, piece, 10, 10, 25);
      }
    }

    // Check collision
    function collision(piece, moveX = 0, moveY = 0) {
      for (let y = 0; y < piece.shape.length; y++) {
        for (let x = 0; x < piece.shape[y].length; x++) {
          if (piece.shape[y][x]) {
            const newX = piece.x + x + moveX;
            const newY = piece.y + y + moveY;

            if (newX < 0 || newX >= COLS || newY >= ROWS) {
              return true;
            }
            if (newY >= 0 && board[newY][newX]) {
              return true;
            }
          }
        }
      }
      return false;
    }

    // Merge piece to board
    function merge() {
      currentPiece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            const boardY = currentPiece.y + y;
            const boardX = currentPiece.x + x;
            if (boardY >= 0) {
              board[boardY][boardX] = currentPiece.color;
            }
          }
        });
      });
    }

    // Rotate piece
    function rotate() {
      const rotated = currentPiece.shape[0].map((_, i) =>
        currentPiece.shape.map(row => row[i]).reverse()
      );
      const previousShape = currentPiece.shape;
      currentPiece.shape = rotated;

      if (collision(currentPiece)) {
        currentPiece.shape = previousShape;
      } else {
        createParticles(currentPiece.x * BLOCK_SIZE + 15, currentPiece.y * BLOCK_SIZE + 15, currentPiece.color);
      }
    }

    // Move piece
    function move(dir) {
      currentPiece.x += dir;
      if (collision(currentPiece)) {
        currentPiece.x -= dir;
      }
    }

    // Drop piece
    function drop() {
      currentPiece.y++;
      if (collision(currentPiece)) {
        currentPiece.y--;
        merge();
        clearLines();
        spawnPiece();
      }
      dropCounter = 0;
    }

    // Hard drop
    function hardDrop() {
      let dropDistance = 0;
      while (!collision(currentPiece, 0, 1)) {
        currentPiece.y++;
        dropDistance++;
      }
      score += dropDistance * 2;
      createParticles(currentPiece.x * BLOCK_SIZE + 15, currentPiece.y * BLOCK_SIZE + 15, currentPiece.color);
      merge();
      clearLines();
      spawnPiece();
      updateScore();
    }

    // Hold piece
    function hold() {
      if (!canHold) return;

      if (holdPiece === null) {
        holdPiece = currentPiece;
        spawnPiece();
      } else {
        const temp = holdPiece;
        holdPiece = currentPiece;
        currentPiece = temp;
        currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
        currentPiece.y = 0;
      }
      canHold = false;
      drawHold();
      createParticles(150, 100, '#b800ff');
    }

    // Clear lines
    function clearLines() {
      let linesCleared = 0;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every(cell => cell !== 0)) {
          // Line clear animation
          for (let x = 0; x < COLS; x++) {
            createParticles(x * BLOCK_SIZE + 15, y * BLOCK_SIZE + 15, board[y][x]);
          }

          board.splice(y, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          y++;
        }
      }

      if (linesCleared > 0) {
        lines += linesCleared;
        combo++;

        // Score calculation
        const lineScore = [0, 100, 300, 500, 800][linesCleared] || 0;
        const comboBonus = combo > 1 ? (combo - 1) * 50 : 0;
        score += (lineScore + comboBonus) * level;

        // Show combo
        if (combo > 1) {
          showCombo();
        }

        // Level up
        const newLevel = Math.floor(lines / 10) + 1;
        if (newLevel > level) {
          level = newLevel;
          dropInterval = Math.max(100, 1000 - (level - 1) * 100);
          canvas.classList.add('shake');
          setTimeout(() => canvas.classList.remove('shake'), 300);
        }

        updateScore();
      } else {
        combo = 0;
        hideCombo();
      }
    }

    // Show combo
    function showCombo() {
      const comboDisplay = document.getElementById('comboDisplay');
      const comboCount = document.getElementById('comboCount');
      comboCount.textContent = combo;
      comboDisplay.classList.remove('hidden');
    }

    // Hide combo
    function hideCombo() {
      document.getElementById('comboDisplay').classList.add('hidden');
    }

    // Create particles
    function createParticles(x, y, color) {
      const container = document.getElementById('particle-container');
      const rect = canvas.getBoundingClientRect();

      for (let i = 0; i < 10; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = (rect.left + x + Math.random() * 20 - 10) + 'px';
        particle.style.top = (rect.top + y + Math.random() * 20 - 10) + 'px';
        particle.style.width = (Math.random() * 8 + 4) + 'px';
        particle.style.height = particle.style.width;
        particle.style.background = color;
        particle.style.borderRadius = '50%';
        particle.style.boxShadow = `0 0 10px ${color}`;

        container.appendChild(particle);

        setTimeout(() => particle.remove(), 1000);
      }
    }

    // Spawn piece
    function spawnPiece() {
      currentPiece = nextPiece || createPiece();
      nextPiece = createPiece();
      canHold = true;
      drawNext();

      if (collision(currentPiece)) {
        gameOver();
      }
    }

    // Update score display
    function updateScore() {
      document.getElementById('score').textContent = score;
      document.getElementById('lines').textContent = lines;
      document.getElementById('level').textContent = level;
      document.getElementById('combo').textContent = combo;
    }

    // Game loop
    function update(time = 0) {
      if (isPaused || isGameOver) return;

      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;

      if (dropCounter > dropInterval) {
        drop();
      }

      drawBoard();
      gameLoop = requestAnimationFrame(update);
    }

    // Start game
    function startGame() {
      if (gameLoop) {
        cancelAnimationFrame(gameLoop);
      }

      board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
      score = 0;
      lines = 0;
      level = 1;
      combo = 0;
      dropInterval = 1000;
      isPaused = false;
      isGameOver = false;

      document.getElementById('gameOver').classList.add('hidden');
      document.getElementById('startBtn').textContent = 'RESTART';

      nextPiece = createPiece();
      spawnPiece();
      updateScore();
      hideCombo();

      lastTime = performance.now();
      gameLoop = requestAnimationFrame(update);
    }

    // Restart game
    function restartGame() {
      startGame();
    }

    // Game over
    function gameOver() {
      isGameOver = true;
      cancelAnimationFrame(gameLoop);
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOver').classList.remove('hidden');
      canvas.classList.add('shake');
      setTimeout(() => canvas.classList.remove('shake'), 300);
    }

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (isGameOver || !currentPiece) return;

      switch(e.key) {
        case 'ArrowLeft':
          move(-1);
          break;
        case 'ArrowRight':
          move(1);
          break;
        case 'ArrowDown':
          drop();
          break;
        case 'ArrowUp':
          rotate();
          break;
        case ' ':
          e.preventDefault();
          hardDrop();
          break;
        case 'c':
        case 'C':
          hold();
          break;
        case 'p':
        case 'P':
          isPaused = !isPaused;
          if (!isPaused) {
            lastTime = performance.now();
            gameLoop = requestAnimationFrame(update);
          }
          break;
        case 'Enter':
          if (!gameLoop || isGameOver) {
            startGame();
          }
          break;
      }

      if (!isPaused && !isGameOver) {
        drawBoard();
      }
    });

    // Initial draw
    drawBoard();
    updateScore();
  </script>
</body>
</html>
